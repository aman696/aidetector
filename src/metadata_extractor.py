"""
Metadata Forensics for AI Image Detection.

Analyzes EXIF metadata to determine if an image was captured by a real camera
or generated by AI software.

Key insight: Real camera photos contain rich EXIF metadata (camera make/model,
focal length, ISO, GPS, etc.), while AI-generated images typically have no EXIF
data or only software tags.
"""

from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS
import os
from typing import Dict, Any, Tuple
from src.utils import validate_image_path


# Tags that strongly indicate a real camera photo
CAMERA_TAGS = {
    'Make',           # Camera manufacturer (Canon, Nikon, etc.)
    'Model',          # Camera model
    'FocalLength',    # Lens focal length
    'ExposureTime',   # Shutter speed
    'FNumber',        # Aperture
    'ISOSpeedRatings', # ISO sensitivity
    'Flash',          # Flash fired
    'MeteringMode',   # Metering mode
    'WhiteBalance',   # White balance
    'LensModel',      # Lens information
    'LensMake',       # Lens manufacturer
}

# Tags that indicate post-processing
SOFTWARE_TAGS = {
    'Software',       # Editing software
    'ProcessingSoftware',
}

# Tags that indicate timing/location (moderate evidence of real photo)
CONTEXT_TAGS = {
    'DateTime',           # Date photo was taken
    'DateTimeOriginal',   # Original capture date
    'DateTimeDigitized',  # When digitized
    'GPSInfo',            # GPS coordinates
}


def extract_metadata(image_path: str) -> Dict[str, Any]:
    """
    Extracts EXIF metadata from an image file.
    
    Args:
        image_path: Path to the image file.
        
    Returns:
        Dictionary of tag name → value pairs.
        Empty dict if no EXIF data found.
    """
    validate_image_path(image_path)
    
    try:
        img = Image.open(image_path)
        exif_data = img._getexif()
        
        if exif_data is None:
            return {}
        
        metadata = {}
        for tag_id, value in exif_data.items():
            tag_name = TAGS.get(tag_id, str(tag_id))
            
            # Handle GPSInfo specially (decode sub-tags)
            if tag_name == 'GPSInfo' and isinstance(value, dict):
                gps_data = {}
                for gps_tag_id, gps_value in value.items():
                    gps_tag_name = GPSTAGS.get(gps_tag_id, str(gps_tag_id))
                    gps_data[gps_tag_name] = gps_value
                metadata['GPSInfo'] = gps_data
            else:
                # Convert bytes to string for cleaner output
                if isinstance(value, bytes):
                    try:
                        value = value.decode('utf-8', errors='replace').strip('\x00')
                    except Exception:
                        value = str(value)
                metadata[tag_name] = value
        
        return metadata
        
    except Exception:
        # PNG files, corrupted files, etc. — no EXIF
        return {}


def analyze_metadata(metadata: Dict[str, Any]) -> Dict[str, Any]:
    """
    Analyzes extracted metadata for forensic indicators.
    
    Args:
        metadata: Dictionary of EXIF tag name → value pairs.
        
    Returns:
        Dictionary with analysis results:
            - has_camera_data: bool
            - has_gps: bool
            - has_timestamps: bool
            - has_software: bool
            - camera_tags_found: list of camera tags present
            - software_info: software name if found
            - tag_count: total number of EXIF tags
    """
    analysis = {
        'has_camera_data': False,
        'has_gps': False,
        'has_timestamps': False,
        'has_software': False,
        'camera_tags_found': [],
        'context_tags_found': [],
        'software_info': None,
        'tag_count': len(metadata),
    }
    
    for tag in CAMERA_TAGS:
        if tag in metadata:
            analysis['has_camera_data'] = True
            analysis['camera_tags_found'].append(tag)
    
    if 'GPSInfo' in metadata:
        analysis['has_gps'] = True
    
    for tag in CONTEXT_TAGS:
        if tag in metadata:
            analysis['has_timestamps'] = True
            analysis['context_tags_found'].append(tag)
    
    for tag in SOFTWARE_TAGS:
        if tag in metadata:
            analysis['has_software'] = True
            analysis['software_info'] = str(metadata[tag])
    
    return analysis


def extract_metadata_features(image_path: str) -> Dict[str, float]:
    """
    Extracts numerical features from metadata for the classifier.
    
    Args:
        image_path: Path to image file.
        
    Returns:
        Dictionary of feature name → value.
    """
    metadata = extract_metadata(image_path)
    analysis = analyze_metadata(metadata)
    
    return {
        'meta_tag_count': float(analysis['tag_count']),
        'meta_camera_tags': float(len(analysis['camera_tags_found'])),
        'meta_has_camera': float(analysis['has_camera_data']),
        'meta_has_gps': float(analysis['has_gps']),
        'meta_has_timestamps': float(analysis['has_timestamps']),
        'meta_has_software': float(analysis['has_software']),
    }


def metadata_score(image_path: str) -> float:
    """
    Computes a metadata-based score for AI detection.
    
    Higher score = more likely AI-generated.
    
    Scoring logic:
    - Rich camera EXIF data → likely real (low score)
    - No EXIF data → likely AI (high score)
    - Only software tags → suspicious (medium-high score)
    
    Args:
        image_path: Path to image file.
        
    Returns:
        float: Score between 0.0 and 1.0 (higher = more likely AI).
    """
    features = extract_metadata_features(image_path)
    
    # Check file extension — PNGs rarely have EXIF even from cameras
    ext = os.path.splitext(image_path)[1].lower()
    is_png = ext == '.png'
    
    camera_tags = features['meta_camera_tags']
    has_camera = features['meta_has_camera']
    has_gps = features['meta_has_gps']
    has_timestamps = features['meta_has_timestamps']
    has_software = features['meta_has_software']
    tag_count = features['meta_tag_count']
    
    # Start with neutral score
    score = 0.5
    
    if has_camera:
        # Strong evidence of real photo
        score -= 0.3
        # More camera tags = stronger evidence
        score -= min(camera_tags * 0.03, 0.15)
    
    if has_gps:
        # GPS data strongly suggests real camera
        score -= 0.1
    
    if has_timestamps:
        # Timestamps add some evidence of real capture
        score -= 0.05
    
    if tag_count == 0:
        if is_png:
            # PNGs often lack EXIF even for real images, be lenient
            score += 0.15
        else:
            # JPEG/WEBP with no EXIF is very suspicious
            score += 0.35
    
    if has_software and not has_camera:
        # Software tag without camera data — likely AI or heavily edited
        score += 0.15
    
    # Ensure we're in [0, 1]
    return float(max(0.0, min(1.0, score)))
